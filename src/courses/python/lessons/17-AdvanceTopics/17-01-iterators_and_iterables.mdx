
# Iterators & Iterables

## Understanding How **for** Loops Work
<secction id="understanding-how-for-loops-work"></secction>

We've been using for loops extensively to iterate over sequences like lists, tuples, strings, dictionary views, and ranges. But how does Python actually manage this process of going through items one by one?

The magic behind for loops lies in two related concepts: iterables and iterators. Understanding these concepts provides deeper insight into Python's iteration mechanism and allows us to create our own iterable objects.

## Iterables: Objects You Can Loop Over
<secction id="iterables-objects-you-can-loop-over"></secction>

An iterable is any Python object capable of returning its members one at a time. Technically, an object is considered iterable if it implements the special method `__iter__()`.

When you use a for loop (or other constructs that expect an iterable, like list comprehensions or the in operator), Python first calls the `__iter__()` method on the object you're trying to loop over.

Examples of built-in iterables we've already seen:

*   Lists (`[]`)
*   Tuples (`()`)
*   Strings (`""`)
*   Dictionaries (`{}` - iterates over keys by default)
*   Sets (`{}` or `set()`)
*   Range objects (`range()`)
*   File objects (returned by `open()` - iterates over lines)
*   Dictionary view objects (`.keys()`, `.values()`, `.items()`)

## Iterators: Objects That Track State
<secction id="iterators-objects-that-track-state"></secction>

The __iter__() method of an iterable object is responsible for returning an iterator object.

An iterator is an object that represents a stream of data. It knows how to get the next item in the sequence and keeps track of its current position within that sequence. Technically, an iterator object must implement the `__next__()` method.

*   `__next__()`: This method returns the next item in the sequence. When there are no more items, it must raise the built-in `StopIteration` exception.
*   Iterators also typically implement their own `__iter__()` method that simply returns `self`. This allows iterators themselves to be used where an iterable is expected (like in a **for** loop).

## The Iteration Protocol: How **for** Uses **iter()** and **next()**
<secction id="the-iteration-protocol-how-for-uses-iter-and-next"></secction>

Here's what happens behind the scenes when you write `for item in iterable:`

1.  Python calls `iter(iterable)` (which internally calls `iterable.__iter__()`) to get an iterator object. Let's call it `iterator_obj`.
2.  The **for** loop then enters its repetition phase:
    a.  It calls `next(iterator_obj)` (which internally calls `iterator_obj.__next__()`) to get the next item.
    b.  The returned item is assigned to the loop variable (`item` in this case).
    c.  The code block inside the **for** loop is executed with the current value of `item`.
    d.  The loop repeats step (a).
3.  This continues until `next(iterator_obj)` raises the `StopIteration` exception.
4.  When `StopIteration` is raised, the **for** loop catches it silently and terminates cleanly.

> This separation between iterables (which know how to produce an iterator) and iterators (which know how to produce the next item) is powerful. It allows multiple independent iterations over the same iterable object simultaneously, as each call to **iter()** typically produces a fresh iterator with its own state.

### Example 1: Manual Iteration using **iter()** and **next()**
<secction id="example-1-manual-iteration-using-iter-and-next"></secction>
* **File: manual_iteration.py**
```python
my_list = [10, 20, 30]
print(f"Original list (iterable): {my_list}")
```
* **1. Get an iterator from the iterable list**
```python
iterator_obj = iter(my_list)
print(f"Iterator object: {iterator_obj}")
print(f"Type of iterator: {type(iterator_obj)}") # <class 'list_iterator'>
```
* **Call next() repeatedly**
```python
try:
    print("\nCalling next():")
    item1 = next(iterator_obj)
    print(f"  First item: {item1}") # Output: 10

    item2 = next(iterator_obj)
    print(f"  Second item: {item2}") # Output: 20

    item3 = next(iterator_obj)
    print(f"  Third item: {item3}") # Output: 30

    # 3. Calling next() again raises StopIteration
    print("  Calling next() again...")
    item4 = next(iterator_obj) # This line raises StopIteration
    print(f"  Fourth item: {item4}") # This won't be reached

except StopIteration:
    print("  Caught StopIteration: No more items.")

print("\nDemonstrating independent iterators:")
iter1 = iter(my_list)
iter2 = iter(my_list)

print(f"Next from iter1: {next(iter1)}") # Output: 10
print(f"Next from iter2: {next(iter2)}") # Output: 10 (iter2 is independent)
print(f"Next from iter1: {next(iter1)}") # Output: 20
```

This shows the underlying mechanism that **for** loops automate for us.

### Example 2: Iterating over Dictionary Views
<secction id="example-2-iterating-over-dictionary-views"></secction>

Dictionary views (**.keys()**, **.values()**, **.items()**) are iterables that yield iterators.

```python
# File: dict_view_iteration.py
student_scores = {"Alice": 85, "Bob": 92, "Charlie": 78}

# --- Keys ---
keys_view = student_scores.keys() # Iterable
key_iterator = iter(keys_view)    # Get iterator
print("Keys using iterator:")
try:
    while True: # Loop until StopIteration
        key = next(key_iterator)
        print(f"- {key}")
except StopIteration:
    print("(End of keys)")

# --- Values ---
value_iterator = iter(student_scores.values())
print("\nValues using iterator:")
try:
    while True:
        value = next(value_iterator)
        print(f"- {value}")
except StopIteration:
    print("(End of values)")

# --- Items ---
item_iterator = iter(student_scores.items())
print("\nItems using iterator:")
try:
    while True:
        key, value = next(item_iterator) # Unpack the tuple pair
        print(f"- {key}: {value}")
except StopIteration:
    print("(End of items)")
```

### Example 3: **range** Object is Iterable
<secction id="example-3-range-object-is-iterable"></secction>

```python
# File: range_iteration.py

r = range(3) # range object is iterable
print(f"Range object: {r}")

# Get iterator from range
r_iter = iter(r)
print(f"Range iterator: {r_iter}")

# Use next()
print("\nUsing next() on range iterator:")
print(next(r_iter)) # Output: 0
print(next(r_iter)) # Output: 1
print(next(r_iter)) # Output: 2

try:
    print(next(r_iter)) # Raises StopIteration
except StopIteration:
    print("StopIteration for range.")

# Of course, using a for loop is much easier:
print("\nUsing for loop (preferred):")
for i in range(3):
    print(i)
```

import Quiz from "../../../components/Quiz";
import pythonQuiz from "../../quiz-data/iterator";

<section id="Quiz-time"></section>

<Quiz questions={pythonQuiz} />

