

# Generators 

## Recap: Iterators and Iterables


we learned about the iteration protocol in Python, involving iterables (objects with **__iter__()**) and iterators (objects with **__next__()** and **__iter__()**). We saw how **for** loops use **iter()** and **next()** behind the scenes to process sequences.

While we can create custom iterators by defining classes with **__iter__()** and **__next__()** methods (tracking state manually), Python provides a much simpler and more elegant way to create iterators using **generators**.

## What are Generators?
<section id="what-are-generators"></section>

A generator is a special kind of function that, instead of returning a single value with **return**, uses the **`yield`** keyword to produce a sequence of values over time.

When you call a function that contains a **yield** statement, it doesn't execute the function body immediately. Instead, it returns a **generator object**. This generator object is a type of iterator.

Each time the **__next__()** method is called on the generator object (either explicitly with **next()** or implicitly by a **for** loop):

1.  The function's execution resumes from where it last left off (right after the **yield**).
2.  It continues until it hits the next **yield** statement.
3.  The value specified in the **yield** statement is returned as the result of **__next__()**.
4.  The function's state (including local variables) is paused or "frozen" at the **yield** statement, ready to resume on the next call to **__next__()**.
5.  If the function body finishes or encounters a **return** statement (or just runs off the end), a **StopIteration** exception is raised automatically on the subsequent call to **__next__()**, signaling the end of the iteration.

Generators provide a very memory-efficient way to create iterators, especially for large sequences, because they produce values one at a time ("lazily") only when requested, rather than storing the entire sequence in memory at once.

## Syntax: Using **yield**
<section id="syntax-using-yield"></section>

Any function that contains at least one `yield` statement automatically becomes a generator function.


* **File: simple_generator.py**
```python

def count_up_to(limit):
    """A generator function that yields numbers from 1 up to limit."""
    print(" -> Generator starting...")
    n = 1
    while n <= limit:
        print(f" -> Yielding {n}")
        yield n # Pauses here and returns 'n'
        # Resumes here on the next call to next()
        print(f" -> Resuming after yielding {n}")
        n += 1
    print(" -> Generator finished.")
    # StopIteration is automatically raised after this
```
* **Call the generator function - it returns a generator object**
```python
counter_gen = count_up_to(3)
print(f"Type of returned object: {type(counter_gen)}") # Output: <class 'generator'>

print("\nManually iterating using next():")
try:
    val1 = next(counter_gen)
    print(f"Received: {val1}")
    val2 = next(counter_gen)
    print(f"Received: {val2}")
    val3 = next(counter_gen)
    print(f"Received: {val3}")
    val4 = next(counter_gen) # This will trigger StopIteration
    print(f"Received: {val4}")
except StopIteration:
    print("Caught StopIteration.")

print("\nIterating using a for loop (more common):")
# Calling count_up_to() again creates a<strong>new</strong> generator object
for number in count_up_to(2):
    print(f"For loop received: {number}")        
```

Observe the output carefully. The print statements inside the generator function only execute piece by piece as the **for** loop or **next()** requests values.

## Generator Expressions
<section id="generator-expressions"></section>

Similar to how list comprehensions provide a concise way to create lists, **generator expressions** provide a concise way to create generator objects. They use parentheses `()` instead of square brackets `[]`.

```python
# List comprehension (creates the full list in memory)
squares_list = [x*x for x in range(5)]
print(f"List comprehension: {squares_list}") # Output: [0, 1, 4, 9, 16]
print(f"Type: {type(squares_list)}")        # Output: <class 'list'>

# Generator expression (creates a generator object)
squares_gen = (x*x for x in range(5))
print(f"\nGenerator expression object: {squares_gen}") # Output: <generator object ...>
print(f"Type: {type(squares_gen)}")                 # Output: <class 'generator'>

# To get the values, you iterate over the generator object
print("Values from generator expression:")
for square in squares_gen:
    print(f"- {square}")

# You can only iterate over a generator object once!
print("\nTrying to iterate again:")
for square in squares_gen: # This loop will not run
    print(f"- {square}")
print("(No output - generator exhausted)")

# Convert generator to list (if needed, but consumes the generator)
squares_gen_again = (x*x for x in range(3))
squares_list_from_gen = list(squares_gen_again)
print(f"\nList from generator: {squares_list_from_gen}")
# squares_gen_again is now exhausted too 
```

Generator expressions are particularly useful when you want to process items one by one without building an intermediate list, saving memory.

### Example 1: Generating Fibonacci Numbers
<section id="example-1-generating-fibonacci-numbers"></section>


* **File: fibonacci_generator.py**
```python
def fibonacci(limit):
    """Generates Fibonacci numbers up to a given limit."""
    a, b = 0, 1
    while a < limit:
        yield a
        a, b = b, a + b # Calculate next pair

print("Fibonacci numbers less than 50:")
for num in fibonacci(50):
    print(num, end=" ") # Output: 0 1 1 2 3 5 8 13 21 34
print()
```

### Example 2: Reading Large Files Lazily
<section id="example-2-reading-large-files-lazily"></section>
Generators are ideal for processing large files line by line without loading the whole file into memory.

* **File: large_file_reader.py**
```python

def read_lines(filename):
    """Generator to yield lines from a file one by one."""
    try:
        with open(filename, "r", encoding="utf-8") as f:
            for line in f: # The file object itself acts like a generator of lines
                yield line.strip() # Yield cleaned line
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        # Could also yield an error indicator or raise exception here
    except Exception as e:
        print(f"Error reading file: {e}")

# --- Usage ---
# Create a dummy large file 'my_data.txt' first for testing
# e.g., with lines like "Data line 1", "Data line 2", ...

print("Processing lines from 'my_data.txt':")
line_count = 0
# This processes one line at a time, efficient for large files
for data_line in read_lines("my_data.txt"):
    line_count += 1
    # Process the line (e.g., search, parse, count)
    if line_count <= 5: # Only print first 5 for brevity
        print(f"  Read: {data_line}")
    elif line_count == 6:
        print("  ...") # Indicate more lines are being processed

print(f"\nTotal lines processed: {line_count}")
```

### Example 3: Using Generator Expression for Summation
<section id="example-3-using-generator-expression-for-summation"></section>

```python
# File: gen_expr_sum.py

# Calculate sum of squares from 1 to 1,000,000
# Using a generator expression with sum() is memory efficient
# It avoids creating a massive list of squares first.
large_sum = sum(x*x for x in range(1, 1000001))

print(f"Sum of squares up to 1,000,000 calculated.")
# Printing the actual sum might be very large!
# Let's print sum for a smaller range:
small_sum = sum(x*x for x in range(1, 11))
print(f"Sum of squares (1-10): {small_sum}") # Output: 385

# Compare to list comprehension (less memory efficient for large ranges)
# list_comp_sum = sum([x*x for x in range(1, 1000001)]) # Builds full list first
# print("List comprehension sum calculated.")
```

import Quiz from "../../../components/Quiz";
import pythonQuiz from "../../quiz-data/generators";

<section id="Quiz-time"></section>

<Quiz questions={pythonQuiz} />