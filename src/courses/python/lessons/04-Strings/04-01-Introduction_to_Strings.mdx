# String Basics & Manipulation

## Revisiting Strings (`str`)
<section id="Revisiting-strings"></section>

As we learned, strings are sequences of characters used to represent text data in Python. They are defined using single (`'`), double (`"`), or triple (`'''` or `"""`) quotes.

```python
single_quoted = 'This is a string.'
double_quoted = "This is also a string, useful if you need ' inside."
multi_line = """This string
spans multiple
lines."""
print(single_quoted)
print(double_quoted)
print(multi_line)
```

An important property of Python strings is that they are **immutable**. This means that once a string object is created, its content cannot be changed. Operations that seem to modify a string actually create and return a **new** string object.

## Common String Operations
<section id="Common-string-operations"></section>

### 1. Concatenation (+) and Repetition (*)

You can combine strings using the `+` operator and repeat them using the `*` operator with an integer.

```python
first_name = "Ada"
last_name = "Lovelace"
separator = "- "

full_name = first_name + " " + last_name # Concatenation
print("Full Name:", full_name)

repeated_sep = separator * 5 # Repetition
print("Separator:", repeated_sep)
```

### 2. Finding Length (`len()`)

The built-in `len()` function returns the number of characters in a string.

```python
greeting = "Hello!"
print(f"The length of '{greeting}' is {len(greeting)}") # Output: 6

empty_string = ""
print(f"The length of an empty string is {len(empty_string)}") # Output: 0
```

### 3. Indexing (Accessing Characters)

You can access individual characters in a string using square brackets `[]` and an index. Python uses **zero-based indexing**, meaning the first character is at index 0, the second at index 1, and so on.

Negative indices can be used to access characters from the end of the string: -1 is the last character, -2 is the second-to-last, etc.

```python
#        P  Y  T  H  O  N
# Index:  0  1  2  3  4  5
# NegIdx:-6 -5 -4 -3 -2 -1
language = "PYTHON"

first_char = language[0]
third_char = language[2]
last_char = language[-1]
second_last_char = language[-2]

print(f"First character: {first_char}")   # Output: P
print(f"Third character: {third_char}")   # Output: T
print(f"Last character: {last_char}")    # Output: N
print(f"Second-last character: {second_last_char}") # Output: O

# Trying to access an index outside the range will cause an IndexError
# print(language[6]) # This would raise an IndexError
```

### More on Indexing & Slicing
<section id="More-on-indexing-slicing"></section>
Indexing allows us to access individual characters of a string. Python uses **zero-based indexing**, so the first character is at index `0`, the second at `1`, and so on. Negative indexing starts from the end of the string, where `-1` refers to the last character, `-2` to the second last, etc.

```python
word = "PYTHON"

# Positive Indexing
print(word[0])   # P (first character)
print(word[3])   # H (fourth character)

# Negative Indexing
print(word[-1])  # N (last character)
print(word[-3])  # H (third from last)
```

Slicing lets us extract a part of the string using `string[start:stop:step]`. The `start` index is inclusive, while the `stop` index is exclusive.

```python
text = "Programming"

# Positive slicing
print(text[0:6])   # Progra (from index 0 to 5)
print(text[3:])    # gramming (from index 3 to end)

# Negative slicing
print(text[-7:-1]) # ramming (from -7 to -2)
print(text[:-3])   # Programm (from start to -3)

# Using step
print(text[::2])   # Poraming (every 2nd character)
print(text[::-1])  # gnimmargorP (reversed string)
```

  <table border="1" cellpadding="8" cellspacing="0">
    <thead>
      <tr>
        <th>**Indexing Type**</th>
        <th>**Explanation**</th>
        <th>**Example**</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Positive Indexing</td>
        <td>Starts from <code>0</code> at the first character, 
            <code>1</code> for the second, and so on.</td>
      <code>
  word = "PYTHON"<br />
  word[0] → 'P'<br />
  word[3] → 'H'
</code>

      </tr>
      <tr>
        <td>Negative Indexing</td>
        <td>Starts from <code>-1</code> at the last character, 
            <code>-2</code> for the second last, etc.</td>
        <td>
          <code>
          word = "PYTHON"<br />
          word[-1] → 'N'<br />
          word[-3] → 'H'
          </code>
        </td>
      </tr>
      <tr>
        <td>Slicing (start:stop)</td>
        <td>Extracts characters from <code>start</code> (inclusive) 
            up to <code>stop</code> (exclusive).</td>
        <td>
          <code>
          text = "Programming"<br />
          text[0:6] → 'Progra'<br />
          text[3:] → 'gramming'
          </code>
        </td>
      </tr>
      <tr>
        <td>Slicing with Negative Indices</td>
        <td>Uses negative values to slice from the end.</td>
        <td>
          <code>
          text = "Programming"<br />
          text[-7:-1] → 'ramming'<br />
          text[:-3] → 'Programm'
          </code>
        </td>
      </tr>
      <tr>
        <td>Slicing with Step</td>
        <td>Uses <code>step</code> to skip characters or reverse the string.</td>
        <td>
          <code>
          text = "Programming"<br />
          text[::2] → 'Poraming'<br />
          text[::-1] → 'gnimmargorP'
          </code>
        </td>
      </tr>
    </tbody>
  </table>

### 4. Slicing (Extracting Substrings)

Slicing allows you to extract a portion (substring) of a string using the syntax `string[start:stop:step]`.

*   `start`: The index where the slice begins (inclusive). Defaults to 0 if omitted.
*   `stop`: The index where the slice ends (exclusive). Defaults to the end of the string if omitted.
*   `step`: The amount to increment the index by. Defaults to 1 if omitted.

```python
#        W  e  l  c  o  m  e
# Index: 0  1  2  3  4  5  6
word = "Welcome"
```
* **Get "Wel" (indices 0, 1, 2)**
```python
slice1 = word[0:3]
print(f"word[0:3] -> '{slice1}'")
```
```python
* **Get "come" (indices 3 to end)**
slice2 = word[3:] # Omitting stop goes to the end
print(f"word[3:] -> '{slice2}'")
```
```python
* **Get "Welc" (indices 0 up to 4, exclusive)**
slice3 = word[:4] # Omitting start begins from index 0
print(f"word[:4] -> '{slice3}'")
```
* **Get the whole string (common way to copy)**
```python 
slice4 = word[:]
print(f"word[:] -> '{slice4}'")
```
* **Get every second character -> "Wloe"**
```python
slice5 = word[0:7:2] # or simply word[::2]
print(f"word[::2] -> '{slice5}'")
```
* **Reverse the string -> "emocleW"**
```python
slice6 = word[::-1]
print(f"word[::-1] -> '{slice6}'")
```

## Introduction to String Methods
<section id="Introduction-to-string-methods"></section>

Strings in Python are objects, and objects have associated functions called **methods** that perform operations on the data within the object. String methods are called using dot notation: `string_variable.method_name()`. Remember, since strings are immutable, methods return **new** strings rather than modifying the original.

### Common Formatting Methods
<section id="Common-formatting-methods"></section>
```python
text = "  pYthon PRograMMing is FUN!  "
```
* **Remove leading/trailing whitespace**
```python
clean_text = text.strip()
print(f"strip(): '{clean_text}'")
```
* **Convert to lowercase**
```python
lower_text = text.lower()
print(f"lower(): '{lower_text}'")
```
* **Convert to uppercase**
```python
upper_text = text.upper()
print(f"upper(): '{upper_text}'")
```
* **Capitalize first letter, rest lowercase**
```python
capitalized_text = clean_text.capitalize() # Use the cleaned version first
print(f"capitalize(): '{capitalized_text}'")
```
* **Title case (capitalize first letter of each word)**
```python
title_text = clean_text.title()
print(f"title(): '{title_text}'")
```

### Common Searching/Checking Methods
<section id="Common-searching-checking-methods"></section>
```python
sentence = "The quick brown fox jumps over the lazy dog."
```
* **Check if string starts/ends with a substring**
```python
print(f"Starts with 'The'? {sentence.startswith('The')}")  # True
print(f"Ends with 'dog.'? {sentence.endswith('dog.')}")    # True
print(f"Ends with 'cat.'? {sentence.endswith('cat.')}")    # False
```
* **Find the first occurrence of a substring (returns index or -1 if not found)**
```python
fox_index = sentence.find("fox")
print(f"Index of 'fox': {fox_index}") # Output: 16
cat_index = sentence.find("cat")
print(f"Index of 'cat': {cat_index}") # Output: -1 (not found)
```
* **Count occurrences of a substring**
```python
o_count = sentence.count("o")
the_count = sentence.count("the") # Case-sensitive
print(f"Count of 'o': {o_count}") # Output: 4
print(f"Count of 'the': {the_count}") # Output: 1 ('The' is different)
```

There are many more useful string methods (e.g., `replace()`, `split()`, `join()`, `isdigit()`, `isalpha()`) which we will explore in future lessons as needed.

### Example 1: Extracting Parts of a URL

```python
# File: url_parser.py
url = "https://www.example.com/path/to/resource"

# Find the end of the protocol
protocol_end = url.find("://")
protocol = url[:protocol_end]

# Find the start of the path
path_start = url.find("/", protocol_end + 3) # Start search after "://"
domain = url[protocol_end + 3 : path_start]
path = url[path_start:]

print(f"URL: {url}")
print(f"Protocol: {protocol}")
print(f"Domain: {domain}")
print(f"Path: {path}")
```

### Example 2: Cleaning User Input

```python
# File: clean_input.py
raw_input = "   aLICE   "

# Clean and normalize the name
cleaned_name = raw_input.strip().capitalize()

print(f"Raw input: '{raw_input}'")
print(f"Cleaned name: '{cleaned_name}'") # Output: 'Alice'
```

### Example 3: Simple Palindrome Check

A palindrome reads the same forwards and backwards (ignoring case and spaces).

```python
# File: palindrome_check.py
phrase = "A man a plan a canal Panama"

# 1. Prepare the string: lowercase, remove spaces
prepared_phrase = phrase.lower().replace(" ", "")

# 2. Reverse the prepared string using slicing
reversed_phrase = prepared_phrase[::-1]

# 3. Compare
is_palindrome = prepared_phrase == reversed_phrase

print(f"Original: '{phrase}'")
print(f"Prepared: '{prepared_phrase}'")
print(f"Reversed: '{reversed_phrase}'")
print(f"Is palindrome? {is_palindrome}") # Output: True
```

import Quiz from "../../../../components/Quiz";
import pythonQuiz from "../../../../Data/Strings_questions";

<Quiz questions={pythonQuiz} />