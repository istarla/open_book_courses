
# Arbitrary Arguments 

## Handling an Unknown Number of Arguments
<section id="handling-an-unknown-number-of-arguments"></section>

So far, the functions we've defined require a specific number of arguments (though some might be optional due to default values). But what if you want to create a function that can accept any number of arguments?

For example, a function to calculate the sum of numbers, where the user might provide two, three, or many numbers. Or a function that configures an object using various optional settings provided as keyword arguments.

Python provides special syntax to handle these scenarios using args for arbitrary positional arguments and kwargs for arbitrary keyword arguments.

The names args and kwargs are conventional, but not mandatory. The important parts are the single asterisk (`*`) and the double asterisk (`**`). You could use numbers or options, for example. However, sticking to args and kwargs is highly recommended for readability, as it's a widely understood convention in the Python community.

## Arbitrary Positional Arguments: 
<section id="arbitrary-positional-arguments-args"></section>

When you place a parameter prefixed with a single asterisk (`*`) in your function definition (conventionally `*args`), it collects any "extra" positional arguments passed during the function call into a tuple. This parameter must come after any standard positional parameters and before any keyword-only or kwargs parameters.


* **File: args_example.py**
```python
# The *args parameter collects extra positional arguments into a tuple called 'args'
def sum_all(*args):
    """Calculates the sum of an arbitrary number of arguments."""
    print(f"Arguments received in args tuple: {args}")
    total = 0
    for number in args:
        total += number
    return total
```
* **Call with different numbers of arguments**
```python
result1 = sum_all(1, 2, 3)
print(f"Sum (1, 2, 3): {result1}")

result2 = sum_all(10, 20, 30, 40, 50)
print(f"Sum (10, 20, 30, 40, 50): {result2}")

result3 = sum_all(5)
print(f"Sum (5): {result3}")

result4 = sum_all() # Pass no extra arguments
print(f"Sum (): {result4}")
```
* *Combining standard positional arguments with *args**
```python
def print_info(required_arg, *args):
    print(f"\nRequired argument: {required_arg}")
    print(f"Optional positional arguments (args): {args}")

print_info("Hello") # args is empty tuple: ()
print_info("Hello", 1, 2, "World") # args is (1, 2, "World")
```

Inside the function, `args` behaves just like a regular tuple, so you can iterate over it, access elements by index, etc.

## Arbitrary Keyword Arguments:
<section id="arbitrary-keyword-arguments-kwargs"></section>

When you place a parameter prefixed with a double asterisk (`**`) in your function definition (conventionally kwargs), it collects any keyword arguments passed during the function call that do not match any explicitly defined parameter names. These collected arguments are stored in a dictionary called kwargs, where the keys are the argument keywords (as strings) and the values are the argument values. This parameter must come after all other parameters (positional, default, `*args`).


* **File: kwargs_example.py**
```python
# The **kwargs parameter collects extra keyword arguments into a dictionary
def display_user_profile(**kwargs):
    """Displays user profile information provided as keyword arguments."""
    print("\nUser Profile Data Received:")
    print(f"kwargs dictionary: {kwargs}")
    print("Details:")
    if not kwargs:
        print("  (No details provided)")
        return

    for key, value in kwargs.items():
        print(f"  - {key.replace('_',' ').title()}: {value}") # Format key for display
```
* **Call with different keyword arguments**
```python
display_user_profile(name="Alice", age=30)
display_user_profile(username="bob_dev", email="bob@example.com", country="Canada", status="active")
display_user_profile() # Call with no extra keyword arguments
```
* Combining standard, *args, and **kwargs**
```python
def kitchen_sink(pos1, pos2, *args, kw1="default", **kwargs):
    print(f"\n--- Kitchen Sink Call ---")
    print(f"Positional 1: {pos1}")
    print(f"Positional 2: {pos2}")
    print(f"Arbitrary Positional (args): {args}")
    print(f"Keyword 1 (kw1): {kw1}")
    print(f"Arbitrary Keyword (kwargs): {kwargs}")

kitchen_sink(1, 2) # Only required positional
kitchen_sink(1, 2, 3, 4, 5) # + *args
kitchen_sink(1, 2, 3, 4, kw1="override") # + *args, override kw1
kitchen_sink(1, 2, 3, 4, kw1="override", extra1="hello", extra2=True) # + *args, override kw1, + **kwargs
kitchen_sink(1, 2, extra1="hello", extra2=True) # Only **kwargs (no *args, default kw1)
```

Inside the function, `kwargs` behaves like a regular dictionary, so you can use dictionary methods like `get()`, `items()`, etc.

## Order of Parameters in Definition
<section id="order-of-parameters-in-definition"></section>

When defining a function that uses multiple types of parameters, they must appear in the following order:

1.  Standard positional parameters (no default values).
2.  Standard positional parameters WITH default values.
3.  Arbitrary positional parameters (`*args`).
4.  Keyword-only parameters (parameters that **must** be specified by keyword, can have defaults. Placed after `*args` or just a bare `*`). (More advanced topic, not covered in detail here).
5.  Arbitrary keyword parameters (`**kwargs`).

* **Correct Order Example**
```python
def example_func(a, b, c=10, *args, d, e="default_e", **kwargs):
    # a, b: Standard positional
    # c: Positional with default
    # *args: Arbitrary positional
    # d, e: Keyword-only (d is required, e has default) - Note the * must precede them if args exists
    # **kwargs: Arbitrary keyword
    print(f"a={a}, b={b}, c={c}, args={args}, d={d}, e={e}, kwargs={kwargs}")

# Example call (keyword needed for d)
example_func(1, 2, 3, 4, 5, d="dee", e="eee", f=100, g=200)
# Output: a=1, b=2, c=3, args=(4, 5), d=dee, e=eee, kwargs={'f': 100, 'g': 200}
```

### Example 1: Concatenating Strings
<section id="example-1-concatenating-strings"></section>


* **File: concatenate_strings.py**
```python
def concatenate(*words, separator=" "):
    """Joins an arbitrary number of words with a separator."""
    # 'separator' here is a keyword-only argument because it comes after *words
    return separator.join(words)

result1 = concatenate("Hello", "world") # Uses default separator " "
print(result1) # Output: Hello world

result2 = concatenate("Python", "is", "fun", separator="-") # Override separator
print(result2) # Output: Python-is-fun
```

### Example 2: Building HTML Tags (Simplified)
<section id="example-2-building-html-tags-simplified"></section>
* **File: html_builder.py**
```python
def build_tag(tag_name, content, **attributes):
    """Builds a simple HTML tag with attributes."""
    # Start the opening tag
    tag_str = f"<{tag_name}"

    # Add attributes from kwargs
    for key, value in attributes.items():
        # Replace underscores in keys with hyphens for HTML attributes like data-*
        attr_name = key.replace("_", "-")
        tag_str += f' {attr_name}="{value}"'

    # Close opening tag, add content, add closing tag
    tag_str += f">{content}</{tag_name}>"
    return tag_str
```
* **Build tags**
```python
p_tag = build_tag("p", "This is a paragraph.")
print(p_tag) # Output: <p>This is a paragraph.</p>

a_tag = build_tag(
    "a",
    "Click here",
    href="https://example.com",
    id="link1",
    target="_blank",
    data_info="some_value" # Uses data-info attribute name
)
print(a_tag) # Output: <a href="https://example.com" id="link1" target="_blank" data-info="some_value">Click here</a>

img_tag = build_tag("img", "", src="/images/logo.png", alt="Logo") # Content is empty for img
print(img_tag) # Output: <img src="/images/logo.png" alt="Logo" /> (Note: Self-closing tag logic not added here)
```

### Example 3: Processing Report Data
<section id="example-3-processing-report-data"></section>
* **File: report_processor.py**
```python
def process_report(report_id, *data_points, **metadata):
    """Processes a report with required ID, variable data, and metadata."""
    print(f"\nProcessing Report ID: {report_id}")

    # Process data points (e.g., calculate average)
    if data_points:
        avg = sum(data_points) / len(data_points)
        print(f"  Data Points: {data_points} (Average: {avg:.2f})")
    else:
        print("  No data points provided.")

    # Process metadata
    if metadata:
        print("  Metadata:")
        for key, value in metadata.items():
            print(f"    - {key.title()}: {value}")
    else:
         print("  No metadata provided.")


process_report("Q1-Sales", 100, 150, 120) # ID and *args
process_report("System-Log", timestamp="2025-05-03 11:00", severity="Warning") # ID and **kwargs
process_report("Experiment-X", 0.5, 0.6, 0.55, researcher="Dr. Lee", date="2025-05-03") # ID, *args, and **kwargs
process_report("Empty-Report") # Just the ID
```

import Quiz from "../../../../components/Quiz";
import pythonQuiz from "../../../../Data/arbitrary_arguments";

<Quiz questions={pythonQuiz} />