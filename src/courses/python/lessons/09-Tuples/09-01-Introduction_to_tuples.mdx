# Introduction to Tuples

## Immutable Sequences: Tuples
<section id="tuples"></section>
We've spent the last few days working with lists, which are powerful, ordered, and mutable collections. Python offers another built-in sequence type called a tuple, which is very similar to a list but with one crucial difference: tuples are immutable.

Once a tuple is created, you cannot change its contents â€“ you cannot add, remove, or modify elements.

Like lists, tuples are:

*   **Ordered:** Items maintain their order.
*   **Heterogeneous:** Can contain items of different data types.
*   **Allow Duplicates:** Can contain multiple instances of the same value.

The key difference is their immutability.

## Creating Tuples
<section id="creating-tuples"></section>

Tuples are typically created by enclosing a comma-separated sequence of items within parentheses `()`.
* **An empty tuple**
```python
empty_tuple = ()
print(f"Empty tuple: {empty_tuple}, Type: {type(empty_tuple)}")
```
* **A tuple of integers**
```python
numbers_tuple = (10, 20, 30)
print(f"Numbers tuple: {numbers_tuple}")
```
* **A tuple of strings**
```python
colors_tuple = ("red", "green", "blue")
print(f"Colors tuple: {colors_tuple}")
```
* **A tuple with mixed data types**
```python
mixed_tuple = (1, "tuple", 3.14, False)
print(f"Mixed tuple: {mixed_tuple}")
```
* **Parentheses are optional in many cases (tuple packing)**
```python
point = 10, 20 # This creates a tuple: (10, 20)
print(f"Point tuple (no parens): {point}, Type: {type(point)}")
```
* **Special case: Creating a tuple with a single item requires a trailing comma**
```python
single_item_tuple = (99,) # The comma is essential!
not_a_tuple = (99)    # This is just the integer 99 due to parentheses used for grouping
print(f"Single item tuple: {single_item_tuple}, Type: {type(single_item_tuple)}")
print(f"Not a tuple: {not_a_tuple}, Type: {type(not_a_tuple)}")
```
* **Using the tuple() constructor**
```python
tuple_from_list = tuple([1, 2, 3])
print(f"Tuple from list: {tuple_from_list}") # Output: (1, 2, 3)
tuple_from_string = tuple("abc")
print(f"Tuple from string: {tuple_from_string}") # Output: ('a', 'b', 'c')
```

## Accessing Tuple Items (Indexing & Slicing)
<section id="accessing-tuple-items"></section>


Accessing items in a tuple works exactly the same way as with lists, using zero-based indexing and slicing.
* **Indices:**
```python
          0    1     2     3
coordinates =   (10.5, -3.2, 7.0, 10.5)
```
* **Negative Indices:**
```python
          -4   -3    -2     -4   -3   -2    -1
```
* **Get the first item**
```python
x = coordinates[0]
print(f"First coordinate: {x}") # Output: 10.5
```
* **Get the last item**
```python
last_val = coordinates[-1]
print(f"Last coordinate: {last_val}") # Output: 10.5
```
* **Slicing works the same way as lists**
```python
first_two = coordinates[0:2]
print(f"First two: {first_two}") # Output: (10.5, -3.2) - Slice returns a new tuple
every_other = coordinates[::2]
print(f"Every other: {every_other}") # Output: (10.5, 7.0)
```

## Immutability in Action
<section id="immutability-in-action"></section>

Attempting to modify a tuple after creation will result in a `TypeError`.

```python
my_tuple = (1, 2, 3)
print(f"Original tuple: {my_tuple}")
```
* **Try to change an element - This will cause an error!**
```python
try:
    my_tuple[0] = 100 # Raises TypeError
except TypeError as e:
    print(f"\nError attempting my_tuple[0] = 100: {e}")
```
1.Methods like append, insert, remove, pop, sort DO NOT EXIST for tuples
2.because they modify the sequence in-place.
3.For example, this would cause an AttributeError:
* **my_tuple.append(4)**
```python

If you need a modified version of a tuple, you typically create a new tuple by concatenating slices or converting to a list, modifying the list, and converting back to a tuple.
```
* **Creating a 'modified' tuple (actually a new tuple)**
```python
tuple1 = (1, 2, 3)
tuple2 = (4, 5)

new_tuple = tuple1 + tuple2 # Concatenation creates a new tuple
print(f"\nConcatenated tuple: {new_tuple}") # Output: (1, 2, 3, 4, 5)
```
* **Convert to list, modify, convert back**
```python
temp_list = list(tuple1)
temp_list.append(100)
modified_tuple = tuple(temp_list)
print(f"Modified via list: {modified_tuple}") # Output: (1, 2, 3, 100)
```

## Why Use Tuples?
<section id="why-use-tuples"></section>

Given that lists are more flexible due to their mutability, why use tuples?

*   **Data Integrity:** Immutability guarantees that the tuple's contents remain constant after creation. This is useful for representing fixed collections of data, like coordinates, RGB color values, or records that shouldn't change.
*   **Performance:** Tuples can be slightly more memory-efficient and faster to process than lists in some CPython implementations, partly due to their fixed size. (Though this difference is often minor in practice).
*   **Dictionary Keys:** Tuples can be used as keys in dictionaries (which we'll learn about soon) because they are immutable and hashable. Lists cannot be used as dictionary keys because their contents can change.
*   **Function Arguments/Return Values:** Tuples are often used to return multiple values from a function efficiently.

> Generally, use lists when you need a collection that might change size or content. Use tuples when you need a fixed, ordered collection of items that should not change.

### Example 1: Representing Fixed Data (RGB Color)
<section id="example-1-representing-fixed-data-rgb-color"></section>
* **File: rgb_color.py**
```python
red = (255, 0, 0)
green = (0, 255, 0)
blue = (0, 0, 255)
custom_color = (128, 50, 200)

print(f"Red color tuple: {red}")
print(f"Green component of green: {green[1]}") # Accessing G component
```
Trying to change it would fail, ensuring color integrity
red[0] = 100 # TypeError

### Example 2: Iterating Through a Tuple
<section id="example-2-iterating-through-a-tuple"></section>

You iterate through tuples using `for` loops just like lists.
* **File: tuple_iteration.py**
```python
days_of_week = ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
print("Days of the week:")
for day in days_of_week:
    print(f"- {day}")
```
* **Check if an item exists in a tuple**
```python
if "Friday" in days_of_week:
    print("\nYes, 'Friday' is in the tuple.")
```

### Example 3: Tuple Methods (`count` and `index`)
<section id="example-3-tuple-methods-count-and-index"></section>

While tuples don't have methods that modify them, they do have `count()` and `index()` which work just like their list counterparts.
* **File: tuple_methods.py**
```python
data_points = (1, 5, 2, 8, 5, 3, 5)
print(f"Data: {data_points}")
```
* **Count occurrences of the number 5**
```python
count_5 = data_points.count(5)
print(f"Count of 5: {count_5}") # Output: 3
```
* **Find the index of the first occurrence of 8**
```python
try:
    index_8 = data_points.index(8)
    print(f"Index of first 8: {index_8}") # Output: 3
except ValueError:
    print("Value not found.")
```

import Quiz from "../../../components/Quiz";
import pythonQuiz from "../../quiz-data/introduction_to_tuples";

<section id="Quiz-time"></section>

<Quiz questions={pythonQuiz} />